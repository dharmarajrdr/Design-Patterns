A design pattern is a general, **reusable solution to a commonly occurring problem** within a given context in software design. It is not a finished design that can be transformed directly into code but rather a description or template for how to solve a problem that can be used in many different situations. Design patterns **help to speed up the development process by providing tested, proven development paradigms.**

Key points about design patterns:
1. **Reusability**: They promote code reuse and reduce redundancy.
2. **Best Practices**: They encapsulate best practices and the experiences of developers.
3. **Efficiency**: They help in writing well-structured and maintainable code, leading to better performance and easier debugging.

Design patterns can be broadly categorized into three types:
1. **Creational Patterns**: These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Examples include *Singleton, Factory, and Builder patterns*.
2. **Structural Patterns**: These patterns deal with object composition or how classes and objects can be composed to form larger structures. Examples include *Adapter, Composite, and Proxy patterns*.
3. **Behavioral Patterns**: These patterns deal with object interaction and responsibility. They help in defining communication between objects and the flow of control in a program. Examples include *Observer, Strategy, and Command patterns*.

Each design pattern provides a solution to a problem in a specific context and can be adapted to fit the needs of the situation at hand.

---

| **Pattern**            | **Type**       | **Problem**                                                                 | **Solution**                                                                                                                                                                              |
|------------------------|----------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Singleton**          | Creational     | Need only one instance of a class (e.g., config, logging).                  | Ensures only one instance exists and provides global access to it.                                                                                                                         |
| **Factory Method**     | Creational     | Don't want to specify the exact class to instantiate.                      | Defines a method for creating objects in a subclass, leaving the choice of which object to instantiate to the subclass.                                                                   |
| **Abstract Factory**   | Creational     | Need families of related objects but want to switch between them easily.    | Provides an interface to create related objects without knowing their concrete classes.                                                                                                    |
| **Builder**            | Creational     | Object construction is complex with many optional parameters.              | Separates object construction from its representation, making it easy to create complex objects step by step.                                                                              |
| **Prototype**          | Creational     | Creating objects is costly (e.g., large or complex objects).               | Creates new objects by copying existing ones, reducing the cost of creation.                                                                                                               |
| **Adapter**            | Structural     | Two incompatible interfaces need to work together.                         | Converts one interface into another so incompatible classes can work together.                                                                                                             |
| **Bridge**             | Structural     | Tight coupling between abstraction and implementation.                     | Decouples abstraction from implementation, allowing both to vary independently.                                                                                                            |
| **Composite**          | Structural     | Need to treat individual objects and groups uniformly (e.g., file systems). | Composes objects into tree structures to represent part-whole hierarchies, treating both individual and composite objects uniformly.                                                       |
| **Decorator**          | Structural     | Need to add functionality dynamically without modifying the original code.  | Wraps the object with additional behavior dynamically while keeping the original object's interface intact.                                                                                 |
| **Facade**             | Structural     | Complex subsystems with too many interfaces make usage hard.               | Provides a simplified interface to a larger body of code, making it easier to use.                                                                                                         |
| **Flyweight**          | Structural     | Many similar objects consume too much memory (e.g., rendering text).       | Shares common parts of objects to save memory while maintaining the unique parts.                                                                                                          |
| **Proxy**              | Structural     | Need controlled access to an object (e.g., lazy loading, security).        | Provides a placeholder for another object to control access, reduce cost, or add functionality.                                                                                            |
| **Strategy**           | Behavioral     | Need to switch between different algorithms easily.                        | Encapsulates algorithms in separate classes, allowing them to be swapped at runtime without altering the client code.                                                                      |
| **Observer**           | Behavioral     | Want to notify multiple objects when one object changes its state.         | Allows an object (subject) to notify a group of observer objects automatically when its state changes.                                                                                     |
| **Command**            | Behavioral     | Need to encapsulate requests as objects to handle undo, logging, etc.      | Encapsulates a request as an object, allowing parameterization, queuing, and undoable operations.                                                                                          |
| **Chain of Responsibility** | Behavioral | Multiple objects could handle a request, but which one should?             | Passes the request along a chain of handlers, allowing each handler to process or pass it further.                                                                                         |
| **Mediator**           | Behavioral     | Too many direct interactions between objects lead to tight coupling.       | Introduces a mediator to centralize communication between objects, reducing coupling.                                                                                                      |
| **Memento**            | Behavioral     | Need to restore an object to a previous state (e.g., undo functionality).  | Captures the objectâ€™s state in a memento so it can be restored later.                                                                                                                      |
| **State**              | Behavioral     | Object behavior changes based on its state.                                | Encapsulates state-specific behavior into separate classes, allowing the object to change behavior at runtime by changing its state.                                                       |
| **Template Method**    | Behavioral     | Common algorithm structure, but steps may vary.                            | Defines the skeleton of an algorithm in a base class, allowing subclasses to define or override specific steps.                                                                             |
| **Visitor**            | Behavioral     | Need to perform new operations on a set of objects without modifying them. | Separates an algorithm from the object structure, allowing new operations to be added without changing the objects.                                                                         |
| **Interpreter**        | Behavioral     | Need to interpret or evaluate language grammar (e.g., SQL, regex).         | Defines a grammar and provides a way to evaluate sentences in that grammar, encapsulating the logic for interpreting expressions.                                                          |

